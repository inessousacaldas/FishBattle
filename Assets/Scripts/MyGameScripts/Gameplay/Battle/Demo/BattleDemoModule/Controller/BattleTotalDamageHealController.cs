// **********************************************************************
// Copyright (c) 2016 Baoyugame. All rights reserved.
// Author : MarsZ
// Created : 03/21/2017 10:49:31
// Desc	: Auto generated by MarsZ. update this if need.
// **********************************************************************

using UnityEngine;
using System.Collections.Generic;
using AppDto;
using AppServices;
using System.Collections;

/// <summary>
/// This is the controller class for module BattleTotalDamageHeal, use this to control the ui or view , such as it's init , update or dispose.
/// @MarsZ in 03/21/2017 10:49:31
/// </summary>
public class BattleTotalDamageHealController : MonolessViewController<BattleTotalDamageHealView>
{
    #region property and field

    #region const

    #endregion


    #region data

    #endregion

    #endregion

    #region interface functions

    /// <summary>
    /// 界面就绪后初始化，一个UI生命周期只会执行一次
    /// </summary>
    protected override void AfterInitView ()
    {
        View.CntrLeftDamageInfoUI.SetActive(false);
    }

    //添加事件监听 在gameeventlistener和eventlistener中添加的回调不需要自己remove，所以没有一个相应的RemoveCustomEvent函数
    protected override void RegistCustomEvent ()
    {
        GameEventCenter.AddListener(GameEvent.BATTLE_UI_UPDATE_ACTION_TOTAL_DAMAGE_OR_HEAL,UpdateActionTotalDamageOrHealInfoUI);
    }

    protected override void RemoveCustomEvent()
    {
        GameEventCenter.RemoveListener(GameEvent.BATTLE_UI_UPDATE_ACTION_TOTAL_DAMAGE_OR_HEAL,UpdateActionTotalDamageOrHealInfoUI);
    }

    //收到界面销毁后的回收处理，比如引用置空等
    protected override void OnDispose()
    {
    }

    #endregion

    #region Event Handlers

    #endregion

    #region Public or open interface


    #endregion

    #region Update global UI

    #region 当前行动者的总伤害或总治疗的显示

    //这个方法不能随便调用，因为数值不和谐的话，是直接隐藏相关UI的，可能导致之前要正常显示的相关UI立即隐藏了。
    public void UpdateActionTotalDamageOrHealInfoUI(BattlePosition.MonsterSide pMonsterSide, int pDamageOrHeal)
    {
        if (pDamageOrHeal > 0)
            UpdateActionTotalDamageOrHealInfoUI(0, pDamageOrHeal);
        else if (pDamageOrHeal < 0)
            UpdateActionTotalDamageOrHealInfoUI(-pDamageOrHeal, 0);
        else
            UpdateActionTotalDamageOrHealInfoUI(0, 0);
        ShowDamageHealEffect();
    }

    private void UpdateActionTotalDamageOrHealInfoUI(int pTotalDamage, int pTotalHeal)
    {
        if (pTotalDamage > 0)
        {//优先显示伤害
            View.CntrLeftDamageInfoUI.SetActive(true);
            View.LabelDamageInfo_UILabel.gameObject.SetActive(true);
            View.LabelHealInfo_UILabel.gameObject.SetActive(false);
            View.LabelDamageInfo_UILabel.text = pTotalDamage.ToString();
        }
        else if (pTotalHeal > 0)
        {
            View.CntrLeftDamageInfoUI.SetActive(true);
            View.LabelDamageInfo_UILabel.gameObject.SetActive(false);
            View.LabelHealInfo_UILabel.gameObject.SetActive(true);
            View.LabelHealInfo_UILabel.text = pTotalHeal.ToString();
        }
        else
        {
            View.CntrLeftDamageInfoUI.SetActive(false);
        }
    }

    private void ShowDamageHealEffect()
    {
        if (View.CntrLeftDamageInfoUI.activeInHierarchy)
        {
            View.CntrLeftDamageInfoUIBG_UISprite.alpha = 1;
            View.CntrLeftDamageInfoUI_TweenAlpha.ResetToBeginning();
            View.CntrLeftDamageInfoUI_TweenAlpha.PlayForward();
        }
    }

    #endregion
    #endregion
}
